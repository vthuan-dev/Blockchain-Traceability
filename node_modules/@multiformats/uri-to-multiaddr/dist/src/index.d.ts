/**
 * @packageDocumentation
 *
 * ```js
 * const toMultiaddr = require('uri-to-multiaddr')
 *
 * console.log(toMultiaddr('https://protocol.ai'))
 * // -> /dns4/protocol.ai/tcp/443/https
 * ```
 *
 * Domain names can represent one of
 *
 * - `/dns4` - domain resolves to an ipv4 address (**default**)
 * - `/dns6` - domain resolves to an ipv6 address
 * - `/dnsaddr` - domain has a [DNSLink](https://docs.ipfs.io/guides/concepts/dnslink/) TXT record pointing to an IPFS CID
 *
 * This library assumes `/dns4` when it finds a domain name in the input string.
 * It makes no attempt query DNS. To override the default assumption, you can pass
 * in an options object as the second parameter to override it:
 *
 * ```js
 * const toMultiaddr = require('uri-to-multiaddr')
 *
 * console.log(toMultiaddr('https://protocol.ai'), { defaultDnsType: 'dns6' })
 * // -> /dns6/protocol.ai/tcp/443/https
 * ```
 *
 * See [test.js](./test.js) for the currently supported conversions.
 *
 * **Note**: `uri-to-multiaddr` will throw if the passed URI:
 *
 * - is not a valid, according the WHATWG URL spec implementation used.
 * - is not supported yet
 *
 * ## Related
 *
 * - [multiaddr-to-uri](https://github.com/multiformats/js-multiaddr-to-uri) - convert it back again
 */
import type { Multiaddr } from '@multiformats/multiaddr';
export interface MultiaddrFromUriOpts {
    defaultDnsType?: string;
}
/**
 * Convert a URI to a multiaddr
 *
 * http://foobar.com => /dns4/foobar.com/tcp/80/http
 * https://foobar.com => /dns4/foobar.com/tcp/443/https
 * https://foobar.com:5001 => /dns4/foobar.com/tcp/5001/https
 * https://127.0.0.1:8080 => /ip4/127.0.0.1/tcp/8080/https
 * http://[::1]:8080 => /ip6/::1/tcp/8080/http
 * tcp://foobar.com:8080 => /dns4/foobar.com/tcp/8080
 * udp://foobar.com:8080 => /dns4/foobar.com/udp/8080
 */
export default function multiaddrFromUri(uriStr: string, opts?: MultiaddrFromUriOpts): Multiaddr;
//# sourceMappingURL=index.d.ts.map