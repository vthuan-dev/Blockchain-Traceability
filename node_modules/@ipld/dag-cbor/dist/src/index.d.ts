/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */
/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */
/**
 * @template T
 * @param {ByteView<T> | ArrayBufferView<T>} buf
 * @returns {ByteView<T>}
 */
export function toByteView<T>(buf: import("multiformats/cid").ByteView<T> | import("multiformats/codecs/interface").ArrayBufferView<T>): import("multiformats/cid").ByteView<T>;
export namespace encodeOptions {
    namespace typeEncoders {
        export { cidEncoder as Object };
        export { undefinedEncoder as undefined };
        export { numberEncoder as number };
    }
    let float64: boolean;
}
export namespace decodeOptions {
    let tags: import("cborg/interface").TagDecoder[];
    let allowIndefinite: boolean;
    let coerceUndefinedToNull: boolean;
    let allowNaN: boolean;
    let allowInfinity: boolean;
    let allowBigInt: boolean;
    let strict: boolean;
    let useMaps: boolean;
    let rejectDuplicateMapKeys: boolean;
}
export const name: "dag-cbor";
export const code: 113;
export function encode<T>(node: T): import("multiformats/cid").ByteView<T>;
export function decode<T>(data: import("multiformats/cid").ByteView<T> | import("multiformats/codecs/interface").ArrayBufferView<T>): T;
export type ByteView<T> = import('multiformats/codecs/interface').ByteView<T>;
export type ArrayBufferView<T> = import('multiformats/codecs/interface').ArrayBufferView<T>;
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal.
 *
 * @param {any} obj
 * @returns {cborg.Token[]|null}
 */
declare function cidEncoder(obj: any): cborg.Token[] | null;
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */
declare function undefinedEncoder(): null;
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */
declare function numberEncoder(num: number): null;
import * as cborg from 'cborg';
export {};
//# sourceMappingURL=index.d.ts.map