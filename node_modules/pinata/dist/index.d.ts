type PinataConfig = {
    pinataJwt: string | undefined;
    pinataGateway?: string;
    pinataGatewayKey?: string;
    customHeaders?: Record<string, string>;
    endpointUrl?: string;
};
type AuthTestResponse = {
    message: string;
};
type PinResponse = {
    IpfsHash: string;
    PinSize: number;
    Timestamp: string;
    isDuplicate?: boolean;
};
type PinByCIDResponse = {
    id: string;
    ipfsHash: string;
    status: "prechecking" | "retrieving";
    name: string;
    updated?: boolean;
};
type FileObject = {
    name: string;
    size: number;
    type: string;
    lastModified: number;
    arrayBuffer: () => Promise<ArrayBuffer>;
};
type JsonBody = Record<string, unknown>;
type PinataMetadata = {
    name?: string;
    keyValues?: Record<string, string | number>;
};
type PinataMetadataUpdate = {
    cid: string;
    name?: string;
    keyValues?: Record<string, string | number>;
};
type UploadOptions = {
    metadata?: PinataMetadata;
    pinType?: "async" | "sync" | "cidOnly";
    keys?: string;
    groupId?: string;
    cidVersion?: 0 | 1;
};
type UploadCIDOptions = {
    metadata?: PinataMetadata;
    peerAddresses?: string[];
    keys?: string;
    groupId?: string;
};
type UnpinResponse = {
    hash: string;
    status: string;
};
type PinListItem = {
    id: string;
    ipfs_pin_hash: string;
    size: number;
    user_id: string;
    date_pinned: string;
    date_unpinned: string | null;
    metadata: {
        name: string | null;
        keyvalues: {
            [key: string]: any;
        } | null;
    };
    regions: {
        regionId: string;
        currentReplicationCount: number;
        desiredReplicationCount: number;
    }[];
    mime_type: string;
    number_of_files: number;
};
type PinListResponse = {
    rows: PinListItem[];
};
type PinListQuery = {
    cid?: string;
    pinStart?: string;
    pinEnd?: string;
    pinSizeMin?: number;
    pinSizeMax?: number;
    pageLimit?: number;
    pageOffset?: number;
    name?: string;
    groupId?: string;
    key?: string;
    value?: string | number;
    operator?: "gt" | "gte" | "lt" | "lte" | "ne" | "eq" | "between" | "notBetween" | "like" | "notLike" | "iLike" | "notILike" | "regexp" | "iRegexp";
};
type PinJobQuery = {
    sort?: "ASC" | "DSC";
    status?: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node";
    ipfs_pin_hash?: string;
    limit?: number;
    offset?: number;
};
type PinJobItem = {
    id: string;
    ipfs_pin_hash: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: any;
    host_nodes: string[];
    pin_policy: {
        regions: {
            id: string;
            desiredReplicationCount: number;
        }[];
        version: number;
    };
};
type PinJobResponse = {
    rows: PinJobItem[];
};
type ContentType = "application/json" | "application/xml" | "text/plain" | "text/html" | "text/css" | "text/javascript" | "application/javascript" | "image/jpeg" | "image/png" | "image/gif" | "image/svg+xml" | "audio/mpeg" | "audio/ogg" | "video/mp4" | "application/pdf" | "application/octet-stream" | string | null;
type GetCIDResponse = {
    data?: JSON | string | Blob | null;
    contentType: ContentType;
};
type OptimizeImageOptions = {
    width?: number;
    height?: number;
    dpr?: number;
    fit?: "scaleDown" | "contain" | "cover" | "crop" | "pad";
    gravity?: "auto" | "side" | string;
    quality?: number;
    format?: "auto" | "webp";
    animation?: boolean;
    sharpen?: number;
    onError?: boolean;
    metadata?: "keep" | "copyright" | "none";
};
type GatewayAnalyticsQuery = {
    gateway_domain: string;
    start_date: string;
    end_date: string;
    cid?: string;
    file_name?: string;
    user_agent?: string;
    country?: string;
    region?: string;
    referer?: string;
    limit?: number;
    sort_order?: "asc" | "desc";
};
type TopGatewayAnalyticsQuery = GatewayAnalyticsQuery & {
    sort_by: "requests" | "bandwidth";
    attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name";
};
type TopGatewayAnalyticsItem = {
    value: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalGatewayAnalyticsQuery = GatewayAnalyticsQuery & {
    sort_by?: "requests" | "bandwidth";
    date_interval: "day" | "week";
};
type TimePeriodItem = {
    period_start_time: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalGatewayAnalyticsResponse = {
    total_requests: number;
    total_bandwidth: number;
    time_periods: TimePeriodItem[];
};
type UserPinnedDataResponse = {
    pin_count: number;
    pin_size_total: number;
    pin_size_with_replications_total: number;
};
type KeyPermissions = {
    admin?: boolean;
    endpoints?: Endpoints;
};
type Endpoints = {
    data?: DataEndponts;
    pinning?: PinningEndpoints;
};
type DataEndponts = {
    pinList?: boolean;
    userPinnedDataTotal?: boolean;
};
type PinningEndpoints = {
    hashMetadata?: boolean;
    hashPinPolicy?: boolean;
    pinByHash?: boolean;
    pinFileToIPFS?: boolean;
    pinJSONToIPFS?: boolean;
    pinJobs?: boolean;
    unpin?: boolean;
    userPinPolicy?: boolean;
};
type KeyOptions = {
    keyName: string;
    permissions: KeyPermissions;
    maxUses?: number;
};
type KeyResponse = {
    JWT: string;
    pinata_api_key: string;
    pinata_api_secret: string;
};
type KeyListQuery = {
    revoked?: boolean;
    limitedUse?: boolean;
    exhausted?: boolean;
    name?: string;
    offset?: number;
};
type KeyListItem = {
    id: string;
    name: string;
    key: string;
    secret: string;
    max_uses: number;
    uses: number;
    user_id: string;
    scopes: KeyScopes;
    revoked: boolean;
    createdAt: string;
    updatedAt: string;
};
type KeyScopes = {
    endpoints: {
        pinning: {
            pinFileToIPFS: boolean;
            pinJSONToIPFS: boolean;
        };
    };
    admin: boolean;
};
type KeyListResponse = {
    keys: KeyListItem[];
    count: number;
};
type RevokeKeyResponse = {
    key: string;
    status: string;
};
type GroupOptions = {
    name: string;
};
type UpdateGroupOptions = {
    name: string;
    groupId: string;
};
type GetGroupOptions = {
    groupId: string;
};
type GroupResponseItem = {
    id: string;
    user_id: string;
    name: string;
    updatedAt: string;
    createdAt: string;
};
type GroupQueryOptions = {
    nameContains?: string;
    offset?: number;
    limit?: number;
};
type GroupCIDOptions = {
    groupId: string;
    cids: string[];
};
type SignatureOptions = {
    cid: string;
    signature: string;
};
type SignatureResponse = {
    cid: string;
    signature: string;
};
type SwapCidOptions = {
    cid: string;
    swapCid: string;
};
type SwapHistoryOptions = {
    cid: string;
    domain: string;
};
type SwapCidResponse = {
    mappedCid: string;
    createdAt: string;
};
type ContainsCIDResponse = {
    containsCid: boolean;
    cid: string | null;
};

declare class PinataSDK {
    config: PinataConfig | undefined;
    upload: Upload;
    gateways: Gateways;
    usage: Usage;
    keys: Keys;
    groups: Groups;
    signatures: Signatures;
    constructor(config?: PinataConfig);
    setNewHeaders(headers: Record<string, string>): void;
    testAuthentication(): Promise<AuthTestResponse>;
    unpin(files: string[]): Promise<UnpinResponse[]>;
    listFiles(): FilterFiles;
    updateMetadata(options: PinataMetadataUpdate): Promise<string>;
    pinJobs(): FilterPinJobs;
}
declare class UploadBuilder<T> {
    private config;
    private uploadFunction;
    private args;
    private metadata;
    private keys;
    private peerAddresses;
    private version;
    private groupId;
    constructor(config: PinataConfig | undefined, uploadFunction: (config: PinataConfig | undefined, ...args: any[]) => Promise<T>, ...args: any[]);
    addMetadata(metadata: PinataMetadata): UploadBuilder<T>;
    key(jwt: string): UploadBuilder<T>;
    cidVersion(v: 0 | 1): UploadBuilder<T>;
    group(groupId: string): UploadBuilder<T>;
    peerAddress(peerAddresses: string[]): UploadBuilder<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}
declare class Upload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    file(file: FileObject, options?: UploadOptions): UploadBuilder<PinResponse>;
    fileArray(files: FileObject[], options?: UploadOptions): UploadBuilder<PinResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<PinResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<PinResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<PinResponse>;
    cid(cid: string, options?: UploadCIDOptions): UploadBuilder<PinByCIDResponse>;
}
declare class FilterFiles {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    cid(cid: string): FilterFiles;
    pinStart(date: string): FilterFiles;
    pinEnd(date: string): FilterFiles;
    pinSizeMin(size: number): FilterFiles;
    pinSizeMax(size: number): FilterFiles;
    pageLimit(limit: number): FilterFiles;
    pageOffset(offset: number): FilterFiles;
    name(name: string): FilterFiles;
    group(groupId: string): FilterFiles;
    keyValue(key: string, value: string | number, operator?: PinListQuery["operator"]): FilterFiles;
    then(onfulfilled?: ((value: PinListItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<PinListItem, void, unknown>;
    all(): Promise<PinListItem[]>;
}
declare class Gateways {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    get(cid: string): OptimizeImage;
    convert(url: string, gatewayPrefix?: string): Promise<string>;
    containsCID(cid: string): Promise<ContainsCIDResponse>;
    topUsageAnalytics(options: {
        domain: string;
        start: string;
        end: string;
        sortBy: "requests" | "bandwidth";
        attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name";
    }): TopGatewayAnalyticsBuilder;
    dateIntervalAnalytics(options: {
        domain: string;
        start: string;
        end: string;
        interval: "day" | "week";
    }): TimeIntervalGatewayAnalyticsBuilder;
    swapCid(options: SwapCidOptions): Promise<SwapCidResponse>;
    swapHistory(options: SwapHistoryOptions): Promise<SwapCidResponse[]>;
    deleteSwap(cid: string): Promise<string>;
}
declare class OptimizeImage {
    private config;
    private cid;
    private options;
    constructor(config: PinataConfig | undefined, cid: string);
    optimizeImage(options: OptimizeImageOptions): OptimizeImage;
    then(onfulfilled?: ((value: GetCIDResponse) => any) | null): Promise<any>;
}
declare class FilterPinJobs {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    cid(cid: string): FilterPinJobs;
    status(status: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node"): FilterPinJobs;
    pageLimit(limit: number): FilterPinJobs;
    pageOffset(offset: number): FilterPinJobs;
    sort(sort: "ASC" | "DSC"): FilterPinJobs;
    then(onfulfilled?: ((value: PinJobItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<PinJobItem, void, unknown>;
    all(): Promise<PinJobItem[]>;
}
declare class Usage {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    pinnedFileCount(): Promise<number>;
    totalStorageSize(): Promise<number>;
}
declare class Keys {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: KeyOptions): Promise<KeyResponse>;
    list(): FilterKeys;
    revoke(keys: string[]): Promise<RevokeKeyResponse[]>;
}
declare class FilterKeys {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterKeys;
    revoked(revoked: boolean): FilterKeys;
    limitedUse(limitedUse: boolean): FilterKeys;
    exhausted(exhausted: boolean): FilterKeys;
    name(name: string): FilterKeys;
    then(onfulfilled?: ((value: KeyListItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown>;
    all(): Promise<KeyListItem[]>;
}
declare class Groups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    addCids(options: GroupCIDOptions): Promise<string>;
    removeCids(options: GroupCIDOptions): Promise<string>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}
declare class FilterGroups {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterGroups;
    name(nameContains: string): FilterGroups;
    limit(limit: number): FilterGroups;
    then(onfulfilled?: ((value: GroupResponseItem[]) => any) | null): Promise<GroupResponseItem[]>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<GroupResponseItem, void, unknown>;
    all(): Promise<GroupResponseItem[]>;
}
declare class Signatures {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    add(options: SignatureOptions): Promise<SignatureResponse>;
    get(cid: string): Promise<SignatureResponse>;
    delete(cid: string): Promise<string>;
}
declare class GatewayAnalyticsBuilder<T extends GatewayAnalyticsQuery, R> {
    protected config: PinataConfig | undefined;
    protected query: T;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined, query: T);
    cid(cid: string): this;
    fileName(fileName: string): this;
    userAgent(userAgent: string): this;
    country(country: string): this;
    region(region: string): this;
    referer(referer: string): this;
    limit(limit: number): this;
    sort(order: "asc" | "desc"): this;
    private rateLimit;
    protected getAnalytics(): Promise<R>;
    then(onfulfilled?: ((value: R) => any) | null): Promise<any>;
}
declare class TopGatewayAnalyticsBuilder extends GatewayAnalyticsBuilder<TopGatewayAnalyticsQuery, TopGatewayAnalyticsItem[]> {
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string, sortBy: "requests" | "bandwidth", attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name");
    protected getAnalytics(): Promise<TopGatewayAnalyticsItem[]>;
    all(): Promise<TopGatewayAnalyticsItem[]>;
}
declare class TimeIntervalGatewayAnalyticsBuilder extends GatewayAnalyticsBuilder<TimeIntervalGatewayAnalyticsQuery, TimeIntervalGatewayAnalyticsResponse> {
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string, dateInterval: "day" | "week");
    sortBy(sortBy: "requests" | "bandwidth"): this;
    protected getAnalytics(): Promise<TimeIntervalGatewayAnalyticsResponse>;
    all(): Promise<TimeIntervalGatewayAnalyticsResponse>;
}

export { type AuthTestResponse, type ContainsCIDResponse, type ContentType, type DataEndponts, type Endpoints, type FileObject, type GatewayAnalyticsQuery, type GetCIDResponse, type GetGroupOptions, type GroupCIDOptions, type GroupOptions, type GroupQueryOptions, type GroupResponseItem, type JsonBody, type KeyListItem, type KeyListQuery, type KeyListResponse, type KeyOptions, type KeyPermissions, type KeyResponse, type OptimizeImageOptions, type PinByCIDResponse, type PinJobItem, type PinJobQuery, type PinJobResponse, type PinListItem, type PinListQuery, type PinListResponse, type PinResponse, type PinataConfig, type PinataMetadata, type PinataMetadataUpdate, PinataSDK, type PinningEndpoints, type RevokeKeyResponse, type SignatureOptions, type SignatureResponse, type SwapCidOptions, type SwapCidResponse, type SwapHistoryOptions, type TimeIntervalGatewayAnalyticsQuery, type TimeIntervalGatewayAnalyticsResponse, type TimePeriodItem, type TopGatewayAnalyticsItem, type TopGatewayAnalyticsQuery, type UnpinResponse, type UpdateGroupOptions, type UploadCIDOptions, type UploadOptions, type UserPinnedDataResponse };
