(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames;var L=Object.prototype.hasOwnProperty;var _=(e,t)=>{for(var o in t)n(e,o,{get:t[o],enumerable:!0})},g=(e,t,o,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of I(t))!L.call(e,r)&&r!==o&&n(e,r,{get:()=>t[r],enumerable:!(s=A(t,r))||s.enumerable});return e};var v=e=>g(n({},"__esModule",{value:!0}),e);var z={};_(z,{AbortError:()=>c,AggregateCodeError:()=>l,CodeError:()=>a,CustomEvent:()=>h,ERR_INVALID_MESSAGE:()=>X,ERR_INVALID_PARAMETERS:()=>G,ERR_NOT_FOUND:()=>j,ERR_TIMEOUT:()=>F,Ed25519:()=>w,FaultTolerance:()=>p,InvalidCryptoExchangeError:()=>x,InvalidCryptoTransmissionError:()=>m,KEEP_ALIVE:()=>U,RSA:()=>P,StrictNoSign:()=>k,StrictSign:()=>V,TopicValidatorResult:()=>i,TypedEventEmitter:()=>E,UnexpectedPeerError:()=>f,connectionSymbol:()=>S,contentRoutingSymbol:()=>T,isConnection:()=>N,isPeerId:()=>O,isStartable:()=>d,isTransport:()=>B,peerDiscoverySymbol:()=>M,peerIdSymbol:()=>R,peerRoutingSymbol:()=>C,secp256k1:()=>D,serviceCapabilities:()=>K,serviceDependencies:()=>q,setMaxListeners:()=>u,start:()=>Y,stop:()=>H,transportSymbol:()=>b});var S=Symbol.for("@libp2p/connection");function N(e){return e!=null&&!!e[S]}var T=Symbol.for("@libp2p/content-routing");var w="Ed25519",P="RSA",D="secp256k1";var M=Symbol.for("@libp2p/peer-discovery");var R=Symbol.for("@libp2p/peer-id");function O(e){return e!=null&&!!e[R]}var C=Symbol.for("@libp2p/peer-routing");var U="keep-alive";var V="StrictSign",k="StrictNoSign",i;(function(e){e.Accept="accept",e.Ignore="ignore",e.Reject="reject"})(i||(i={}));var b=Symbol.for("@libp2p/transport");function B(e){return e!=null&&!!e[b]}var p;(function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(p||(p={}));var c=class e extends Error{code;type;constructor(t="The operation was aborted"){super(t),this.name="AbortError",this.code=e.code,this.type=e.type}static code="ABORT_ERR";static type="aborted"},a=class extends Error{code;props;constructor(t,o,s){super(t),this.code=o,this.name=s?.name??"CodeError",this.props=s??{}}},l=class extends AggregateError{code;props;constructor(t,o,s,r){super(t,o),this.code=s,this.name=r?.name??"AggregateCodeError",this.props=r??{}}},f=class e extends Error{code;constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError",this.code=e.code}static code="ERR_UNEXPECTED_PEER"},x=class e extends Error{code;constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError",this.code=e.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"},m=class e extends Error{code;constructor(t="Invalid crypto transmission"){super(t),this.name="InvalidCryptoTransmissionError",this.code=e.code}static code="ERR_INVALID_CRYPTO_TRANSMISSION"},F="ERR_TIMEOUT",G="ERR_INVALID_PARAMETERS",j="ERR_NOT_FOUND",X="ERR_INVALID_MESSAGE";var u=(e,...t)=>{try{[...t]}catch{}};var E=class extends EventTarget{#t=new Map;constructor(){super(),u(1/0,this)}listenerCount(t){let o=this.#t.get(t);return o==null?0:o.length}addEventListener(t,o,s){super.addEventListener(t,o,s);let r=this.#t.get(t);r==null&&(r=[],this.#t.set(t,r)),r.push({callback:o,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(t,o,s){super.removeEventListener(t.toString(),o??null,s);let r=this.#t.get(t);r!=null&&(r=r.filter(({callback:y})=>y!==o),this.#t.set(t,r))}dispatchEvent(t){let o=super.dispatchEvent(t),s=this.#t.get(t.type);return s==null||(s=s.filter(({once:r})=>!r),this.#t.set(t.type,s)),o}safeDispatchEvent(t,o={}){return this.dispatchEvent(new h(t,o))}},h=globalThis.CustomEvent;function d(e){return e!=null&&typeof e.start=="function"&&typeof e.stop=="function"}async function Y(...e){let t=[];for(let o of e)d(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStart!=null&&await o.beforeStart()})),await Promise.all(t.map(async o=>{await o.start()})),await Promise.all(t.map(async o=>{o.afterStart!=null&&await o.afterStart()}))}async function H(...e){let t=[];for(let o of e)d(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStop!=null&&await o.beforeStop()})),await Promise.all(t.map(async o=>{await o.stop()})),await Promise.all(t.map(async o=>{o.afterStop!=null&&await o.afterStop()}))}var K=Symbol.for("@libp2p/service-capabilities"),q=Symbol.for("@libp2p/service-dependencies");return v(z);})();
return Libp2PInterface}));
