(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var X=Object.prototype.hasOwnProperty;var Y=(t,r)=>{for(var e in r)n(t,e,{get:r[e],enumerable:!0})},Z=(t,r,e,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of W(r))!X.call(t,o)&&o!==e&&n(t,o,{get:()=>r[o],enumerable:!(s=V(r,o))||s.enumerable});return t};var $=t=>Z(n({},"__esModule",{value:!0}),t);var dr={};Y(dr,{AbortError:()=>c,AlreadyStartedError:()=>U,ConnectionClosedError:()=>E,ConnectionClosingError:()=>f,ConnectionFailedError:()=>h,DialError:()=>D,FaultTolerance:()=>i,InvalidCIDError:()=>P,InvalidCryptoExchangeError:()=>l,InvalidMessageError:()=>w,InvalidMultiaddrError:()=>g,InvalidMultihashError:()=>L,InvalidParametersError:()=>u,InvalidPeerIdError:()=>I,InvalidPrivateKeyError:()=>x,InvalidPublicKeyError:()=>m,KEEP_ALIVE:()=>nr,LimitedConnectionError:()=>K,ListenError:()=>N,MuxerClosedError:()=>b,NotFoundError:()=>v,NotStartedError:()=>M,ProtocolError:()=>C,StreamResetError:()=>y,StreamStateError:()=>S,StrictNoSign:()=>ir,StrictSign:()=>ar,TimeoutError:()=>T,TooManyInboundProtocolStreamsError:()=>R,TooManyOutboundProtocolStreamsError:()=>_,TopicValidatorResult:()=>a,TypedEventEmitter:()=>O,UnexpectedPeerError:()=>p,UnsupportedKeyTypeError:()=>B,UnsupportedOperationError:()=>d,UnsupportedProtocolError:()=>A,connectionSymbol:()=>q,contentRoutingSymbol:()=>rr,isConnection:()=>k,isPeerId:()=>or,isPrivateKey:()=>tr,isPubSub:()=>cr,isPublicKey:()=>z,isStartable:()=>j,isTransport:()=>pr,peerDiscoverySymbol:()=>er,peerIdSymbol:()=>G,peerRoutingSymbol:()=>sr,pubSubSymbol:()=>H,serviceCapabilities:()=>mr,serviceDependencies:()=>xr,setMaxListeners:()=>F,start:()=>lr,stop:()=>ur,transportSymbol:()=>J});var q=Symbol.for("@libp2p/connection");function k(t){return t!=null&&!!t[q]}var rr=Symbol.for("@libp2p/content-routing");function z(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1")&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.toMultihash=="function"&&typeof t.toCID=="function"&&typeof t.verify=="function"}function tr(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1")&&z(t.publicKey)&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.sign=="function"}var er=Symbol.for("@libp2p/peer-discovery");var G=Symbol.for("@libp2p/peer-id");function or(t){return!!t?.[G]}var sr=Symbol.for("@libp2p/peer-routing");var nr="keep-alive";var ar="StrictSign",ir="StrictNoSign",a;(function(t){t.Accept="accept",t.Ignore="ignore",t.Reject="reject"})(a||(a={}));var H=Symbol.for("@libp2p/pubsub");function cr(t){return!!t?.[H]}var J=Symbol.for("@libp2p/transport");function pr(t){return t!=null&&!!t[J]}var i;(function(t){t[t.FATAL_ALL=0]="FATAL_ALL",t[t.NO_FATAL=1]="NO_FATAL"})(i||(i={}));var c=class extends Error{static name="AbortError";constructor(r="The operation was aborted"){super(r),this.name="AbortError"}},p=class extends Error{static name="UnexpectedPeerError";constructor(r="Unexpected Peer"){super(r),this.name="UnexpectedPeerError"}},l=class extends Error{static name="InvalidCryptoExchangeError";constructor(r="Invalid crypto exchange"){super(r),this.name="InvalidCryptoExchangeError"}},u=class extends Error{static name="InvalidParametersError";constructor(r="Invalid parameters"){super(r),this.name="InvalidParametersError"}},m=class extends Error{static name="InvalidPublicKeyError";constructor(r="Invalid public key"){super(r),this.name="InvalidPublicKeyError"}},x=class extends Error{static name="InvalidPrivateKeyError";constructor(r="Invalid private key"){super(r),this.name="InvalidPrivateKeyError"}},d=class extends Error{static name="UnsupportedOperationError";constructor(r="Unsupported operation"){super(r),this.name="UnsupportedOperationError"}},f=class extends Error{static name="ConnectionClosingError";constructor(r="The connection is closing"){super(r),this.name="ConnectionClosingError"}},E=class extends Error{static name="ConnectionClosedError";constructor(r="The connection is closed"){super(r),this.name="ConnectionClosedError"}},h=class extends Error{static name="ConnectionFailedError";constructor(r="Connection failed"){super(r),this.name="ConnectionFailedError"}},b=class extends Error{static name="MuxerClosedError";constructor(r="The muxer is closed"){super(r),this.name="MuxerClosedError"}},y=class extends Error{static name="StreamResetError";constructor(r="The stream has been reset"){super(r),this.name="StreamResetError"}},S=class extends Error{static name="StreamStateError";constructor(r="The stream is in an invalid state"){super(r),this.name="StreamStateError"}},v=class extends Error{static name="NotFoundError";constructor(r="Not found"){super(r),this.name="NotFoundError"}},I=class extends Error{static name="InvalidPeerIdError";constructor(r="Invalid PeerID"){super(r),this.name="InvalidPeerIdError"}},g=class extends Error{static name="InvalidMultiaddrError";constructor(r="Invalid multiaddr"){super(r),this.name="InvalidMultiaddrError"}},P=class extends Error{static name="InvalidCIDError";constructor(r="Invalid CID"){super(r),this.name="InvalidCIDError"}},L=class extends Error{static name="InvalidMultihashError";constructor(r="Invalid Multihash"){super(r),this.name="InvalidMultihashError"}},A=class extends Error{static name="UnsupportedProtocolError";constructor(r="Unsupported protocol error"){super(r),this.name="UnsupportedProtocolError"}},w=class extends Error{static name="InvalidMessageError";constructor(r="Invalid message"){super(r),this.name="InvalidMessageError"}},C=class extends Error{static name="ProtocolError";constructor(r="Protocol error"){super(r),this.name="ProtocolError"}},T=class extends Error{static name="TimeoutError";constructor(r="Timed out"){super(r),this.name="TimeoutError"}},M=class extends Error{static name="NotStartedError";constructor(r="Not started"){super(r),this.name="NotStartedError"}},U=class extends Error{static name="AlreadyStartedError";constructor(r="Already started"){super(r),this.name="AlreadyStartedError"}},D=class extends Error{static name="DialError";constructor(r="Dial error"){super(r),this.name="DialError"}},N=class extends Error{static name="ListenError";constructor(r="Listen error"){super(r),this.name="ListenError"}},K=class extends Error{static name="LimitedConnectionError";constructor(r="Limited connection"){super(r),this.name="LimitedConnectionError"}},R=class extends Error{static name="TooManyInboundProtocolStreamsError";constructor(r="Too many inbound protocol streams"){super(r),this.name="TooManyInboundProtocolStreamsError"}},_=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(r="Too many outbound protocol streams"){super(r),this.name="TooManyOutboundProtocolStreamsError"}},B=class extends Error{static name="UnsupportedKeyTypeError";constructor(r="Unsupported key type"){super(r),this.name="UnsupportedKeyTypeError"}};var F=(t,...r)=>{try{[...r]}catch{}};var O=class extends EventTarget{#r=new Map;constructor(){super(),F(1/0,this)}listenerCount(r){let e=this.#r.get(r);return e==null?0:e.length}addEventListener(r,e,s){super.addEventListener(r,e,s);let o=this.#r.get(r);o==null&&(o=[],this.#r.set(r,o)),o.push({callback:e,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(r,e,s){super.removeEventListener(r.toString(),e??null,s);let o=this.#r.get(r);o!=null&&(o=o.filter(({callback:Q})=>Q!==e),this.#r.set(r,o))}dispatchEvent(r){let e=super.dispatchEvent(r),s=this.#r.get(r.type);return s==null||(s=s.filter(({once:o})=>!o),this.#r.set(r.type,s)),e}safeDispatchEvent(r,e={}){return this.dispatchEvent(new CustomEvent(r,e))}};function j(t){return t!=null&&typeof t.start=="function"&&typeof t.stop=="function"}async function lr(...t){let r=[];for(let e of t)j(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(r.map(async e=>{await e.start()})),await Promise.all(r.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function ur(...t){let r=[];for(let e of t)j(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(r.map(async e=>{await e.stop()})),await Promise.all(r.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}var mr=Symbol.for("@libp2p/service-capabilities"),xr=Symbol.for("@libp2p/service-dependencies");return $(dr);})();
return Libp2PInterface}));
