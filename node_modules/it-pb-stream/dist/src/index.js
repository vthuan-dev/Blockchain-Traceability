/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive Protobuf encoded messages over
 * streams.
 *
 * @example
 *
 * ```typescript
 * import { pbStream } from 'it-pb-stream'
 * import { MessageType } from './src/my-message-type.js'
 *
 * // RequestType and ResponseType have been generate from `.proto` files and have
 * // `.encode` and `.decode` methods for serialization/deserialization
 *
 * const stream = pbStream(duplex)
 * stream.writePB({
 *   foo: 'bar'
 * }, MessageType)
 * const res = await stream.readPB(MessageType)
 * ```
 */
import * as lp from 'it-length-prefixed';
import { Uint8ArrayList } from 'uint8arraylist';
import { pushable } from 'it-pushable';
import { unsigned } from 'uint8-varint';
import errCode from 'err-code';
const defaultLengthDecoder = (buf) => {
    return unsigned.decode(buf);
};
defaultLengthDecoder.bytes = 0;
export function pbStream(duplex, opts = {}) {
    const write = pushable();
    duplex.sink(write).catch((err) => {
        write.end(err);
    });
    duplex.sink = async (source) => {
        for await (const buf of source) {
            write.push(buf);
        }
    };
    let source = duplex.source;
    if (duplex.source[Symbol.iterator] != null) {
        source = duplex.source[Symbol.iterator]();
    }
    else if (duplex.source[Symbol.asyncIterator] != null) {
        source = duplex.source[Symbol.asyncIterator]();
    }
    const readBuffer = new Uint8ArrayList();
    const W = {
        read: async (bytes) => {
            if (bytes == null) {
                // just read whatever arrives
                const { done, value } = await source.next();
                if (done === true) {
                    return new Uint8ArrayList();
                }
                return value;
            }
            while (readBuffer.byteLength < bytes) {
                const { value, done } = await source.next();
                if (done === true) {
                    throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');
                }
                readBuffer.append(value);
            }
            const buf = readBuffer.sublist(0, bytes);
            readBuffer.consume(bytes);
            return buf;
        },
        readLP: async () => {
            let dataLength = -1;
            const lengthBuffer = new Uint8ArrayList();
            const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;
            while (true) {
                // read one byte at a time until we can decode a varint
                lengthBuffer.append(await W.read(1));
                try {
                    dataLength = decodeLength(lengthBuffer);
                }
                catch (err) {
                    if (err instanceof RangeError) {
                        continue;
                    }
                    throw err;
                }
                if (dataLength > -1) {
                    break;
                }
                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
                    throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');
                }
            }
            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
                throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');
            }
            return await W.read(dataLength);
        },
        readPB: async (proto) => {
            // readLP, decode
            const value = await W.readLP();
            if (value == null) {
                throw new Error('Value is null');
            }
            // Is this a buffer?
            const buf = value instanceof Uint8Array ? value : value.subarray();
            return proto.decode(buf);
        },
        write: (data) => {
            // just write
            if (data instanceof Uint8Array) {
                write.push(data);
            }
            else {
                write.push(data.subarray());
            }
        },
        writeLP: (data) => {
            // encode, write
            W.write(lp.encode.single(data, opts));
        },
        writePB: (data, proto) => {
            // encode, writeLP
            W.writeLP(proto.encode(data));
        },
        pb: (proto) => {
            return {
                read: async () => await W.readPB(proto),
                write: (d) => { W.writePB(d, proto); },
                unwrap: () => W
            };
        },
        unwrap: () => {
            const originalStream = duplex.source;
            duplex.source = (async function* () {
                yield* readBuffer;
                yield* originalStream;
            }());
            return duplex;
        }
    };
    return W;
}
//# sourceMappingURL=index.js.map