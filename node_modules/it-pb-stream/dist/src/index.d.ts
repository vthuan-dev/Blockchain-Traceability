/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive Protobuf encoded messages over
 * streams.
 *
 * @example
 *
 * ```typescript
 * import { pbStream } from 'it-pb-stream'
 * import { MessageType } from './src/my-message-type.js'
 *
 * // RequestType and ResponseType have been generate from `.proto` files and have
 * // `.encode` and `.decode` methods for serialization/deserialization
 *
 * const stream = pbStream(duplex)
 * stream.writePB({
 *   foo: 'bar'
 * }, MessageType)
 * const res = await stream.readPB(MessageType)
 * ```
 */
import * as lp from 'it-length-prefixed';
import type { Duplex } from 'it-stream-types';
import { Uint8ArrayList } from 'uint8arraylist';
/**
 * A protobuf decoder - takes a byte array and returns an object
 */
export interface Decoder<T> {
    (data: Uint8Array | Uint8ArrayList): T;
}
/**
 * A protobuf encoder - takes an object and returns a byte array
 */
export interface Encoder<T> {
    (data: T): Uint8Array;
}
/**
 * A message reader/writer that only uses one type of message
 */
export interface MessageStream<T, S extends Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> = Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {
    /**
     * Read a message from the stream
     */
    read: () => Promise<T>;
    /**
     * Write a message to the stream
     */
    write: (d: T) => void;
    /**
     * Unwrap the underlying protobuf stream
     */
    unwrap: () => ProtobufStream<S>;
}
/**
 * Convenience methods for working with protobuf streams
 */
export interface ProtobufStream<Stream extends Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array> = Duplex<Uint8ArrayList, Uint8ArrayList | Uint8Array>> {
    /**
     * Read a set number of bytes from the stream
     */
    read: (bytes?: number) => Promise<Uint8ArrayList>;
    /**
     * Read the next length-prefixed number of bytes from the stream
     */
    readLP: () => Promise<Uint8ArrayList>;
    /**
     * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format
     */
    readPB: <T>(proto: {
        decode: Decoder<T>;
    }) => Promise<T>;
    /**
     * Write the passed bytes to the stream
     */
    write: (input: Uint8Array | Uint8ArrayList) => void;
    /**
     * Write the passed bytes to the stream prefixed by their length
     */
    writeLP: (input: Uint8Array | Uint8ArrayList) => void;
    /**
     * Encode the passed object as a protobuf message and write it's length-prefixed bytes tot he stream
     */
    writePB: <T>(data: T, proto: {
        encode: Encoder<T>;
    }) => void;
    /**
     * Returns an object with read/write methods for operating on one specific type of protobuf message
     */
    pb: <T>(proto: {
        encode: Encoder<T>;
        decode: Decoder<T>;
    }) => MessageStream<T, Stream>;
    /**
     * Returns the underlying stream
     */
    unwrap: () => Stream;
}
export interface Opts {
    poolSize: number;
    minPoolSize: number;
    lengthEncoder: lp.LengthEncoderFunction;
    lengthDecoder: lp.LengthDecoderFunction;
    maxLengthLength: number;
    maxDataLength: number;
}
export declare function pbStream<Stream extends Duplex<Uint8ArrayList, Uint8Array | Uint8ArrayList>>(duplex: Stream, opts?: Partial<Opts>): ProtobufStream<Stream>;
export declare function pbStream<Stream extends Duplex<Uint8ArrayList, Uint8Array | Uint8ArrayList>>(duplex: Duplex<Uint8Array>, opts?: Partial<Opts>): ProtobufStream<Stream>;
//# sourceMappingURL=index.d.ts.map